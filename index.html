<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Recommendation System | Data Science Portfolio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        :root {
            --primary: #2d3748;
            --secondary: #4299e1;
            --background: #f7fafc;
            --text: #1a202c;
            --light-text: #718096;
            --accent: #667eea;
            --code-bg: #edf2f7;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--background);
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            padding: 4rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(45, 55, 72, 0.5), rgba(45, 55, 72, 0.8)), 
                        url('https://api.placeholder.com/400/320') center/cover no-repeat;
            z-index: -1;
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            font-weight: 300;
            margin-top: 0.5rem;
            opacity: 0.9;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        nav {
            background-color: var(--primary);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        nav ul {
            display: flex;
            justify-content: center;
            list-style: none;
            flex-wrap: wrap;
        }
        
        nav ul li {
            padding: 0;
        }
        
        nav ul li a {
            color: white;
            text-decoration: none;
            padding: 1rem 1.5rem;
            display: block;
            transition: all 0.3s ease;
        }
        
        nav ul li a:hover, nav ul li a.active {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        section {
            margin-bottom: 3rem;
            scroll-margin-top: 4rem;
        }
        
        h2 {
            color: var(--primary);
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 0.5rem;
            margin-top: 2rem;
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }
        
        h3 {
            color: var(--primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
        
        h4 {
            color: var(--primary);
            margin-top: 1.25rem;
            margin-bottom: 0.75rem;
            font-size: 1.2rem;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        .highlight {
            background-color: #f0f4fa;
            border-left: 4px solid var(--secondary);
            padding: 1rem;
            margin: 1rem 0;
        }
        
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        .results-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .result-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 1.5rem;
            flex: 1 1 300px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .result-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .metric-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 1.5rem;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            margin: 0.5rem 0;
        }
        
        .metric-label {
            color: var(--light-text);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .process-step {
            position: relative;
            padding-left: 2.5rem;
            margin-bottom: 2.5rem;
        }
        
        .process-step::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            width: 1.5rem;
            height: 1.5rem;
            background-color: var(--secondary);
            border-radius: 50%;
        }
        
        .process-step:not(:last-child)::after {
            content: "";
            position: absolute;
            left: 0.75rem;
            top: 1.5rem;
            width: 2px;
            height: calc(100% + 1rem);
            background-color: var(--secondary);
            transform: translateX(-50%);
        }
        
        .methodology-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .method-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 1.5rem;
            transition: transform 0.3s ease;
        }
        
        .method-card:hover {
            transform: translateY(-5px);
        }
        
        .method-card i {
            font-size: 2.5rem;
            color: var(--secondary);
            margin-bottom: 1rem;
        }
        
        .visualization {
            margin: 2rem 0;
            text-align: center;
        }
        
        .visualization img {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        
        .caption {
            margin-top: 1rem;
            color: var(--light-text);
            font-style: italic;
        }
        
        .conclusion {
            background: linear-gradient(135deg, #f6f9fc, #edf2f7);
            padding: 2rem;
            border-radius: 8px;
            margin: 2rem 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.07);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: var(--primary);
        }
        
        tr:hover {
            background-color: #f8fafc;
        }
        
        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        .feature-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .footer {
            background-color: var(--primary);
            color: white;
            padding: 3rem 0 1rem;
            margin-top: 4rem;
        }
        
        .footer-content {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-bottom: 2rem;
        }
        
        .footer-section {
            flex: 1 1 300px;
            margin-bottom: 2rem;
        }
        
        .footer-section h3 {
            color: black;
            margin-bottom: 1rem;
            position: relative;
            padding-bottom: 0.5rem;
        }
        
        .footer-section h3::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 50px;
            height: 2px;
            background-color: var(--secondary);
        }
        
        .contact-info div {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .contact-info div i {
            width: 25px;
            margin-right: 10px;
            color: var(--secondary);
        }
        
        .social-links {
            margin-top: 1.5rem;
        }
        
        .social-links a {
            display: inline-block;
            width: 38px;
            height: 38px;
            background-color: rgba(255, 255, 255, 0.1);
            color: black;
            text-align: center;
            line-height: 38px;
            border-radius: 50%;
            margin-right: 0.75rem;
            transition: all 0.3s ease;
        }
        
        .social-links a:hover {
            background-color: var(--secondary);
            transform: translateY(-3px);
        }
        
        .footer-bottom {
            text-align: center;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .process-step {
                padding-left: 2rem;
            }
            
            .footer-section {
                flex: 1 1 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Building a Content-Based Movie Recommender System</h1>
            <p class="subtitle">Using NLP and Feature Engineering to Recommend Similar Movies</p>
        </div>
    </header>

    <nav>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#data-understanding">Dataset</a></li>
            <li><a href="#methodology">Methodology</a></li>
            <li><a href="#implementation">Implementation</a></li>
            <li><a href="#results">Results</a></li>
            <li><a href="#evaluation">Evaluation</a></li>
            <li><a href="#technical-implementation">Technical Details</a></li>
            <li><a href="#flask-deployment">Web Application Demo</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
            
        </ul>
    </nav>

    <div class="container">
        <section id="introduction">
            <h2>Introduction</h2>
            <p>Recommendation systems have become a fundamental component of modern digital platforms, helping users discover relevant content among vast catalogs. In this project, I developed a content-based recommendation system for movies using natural language processing (NLP) techniques and machine learning algorithms.</p>
            
            <div class="highlight">
                <p><strong>Key Question:</strong> How can we leverage movie metadata such as overviews, genres, and ratings to make accurate and relevant movie recommendations?</p>
            </div>
            
            <p>The system analyzes movie features including plot summaries, genres, and other metadata to create a robust similarity model that can suggest movies with similar content characteristics. Unlike collaborative filtering approaches that require user interaction data, this content-based method works effectively with only movie metadata, making it particularly useful for new platforms or for recommending niche content with limited user engagement.</p>
            
            <div class="feature-box">
                <h3>Why Content-Based Filtering?</h3>
                <p>In the world of recommendation systems, there are two dominant approaches:</p>
                <ul>
                    <li><strong>Collaborative Filtering:</strong> Recommends items based on preferences of similar users ("users who liked this also liked...")</li>
                    <li><strong>Content-Based Filtering:</strong> Recommends items with similar features to those a user has liked in the past</li>
                </ul>
                <p>Content-based filtering has several distinct advantages that made it ideal for this project:</p>
                <ul>
                    <li><strong>No cold start problem:</strong> Can recommend movies with no user interaction history</li>
                    <li><strong>Transparency:</strong> Recommendations are based on identifiable features, making them more explainable</li>
                    <li><strong>Independence:</strong> Doesn't require large amounts of user data to function effectively</li>
                    <li><strong>Discovery:</strong> Can surface unique or niche content that might be overlooked in popularity-based systems</li>
                </ul>
            </div>
        </section>
        
        <section id="data-understanding">
            <h2>Dataset Understanding</h2>
            <p>The dataset used in this project contains comprehensive metadata for over 45,000 movies including:</p>
            
            <div class="methodology-grid">
                <div class="method-card">
                    <i class="fas fa-film"></i>
                    <h4>Basic Information</h4>
                    <p>Movie titles, original titles, release dates, runtime, and identifiers like IMDB IDs</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-align-left"></i>
                    <h4>Textual Content</h4>
                    <p>Plot summaries (overviews) and taglines that describe the narrative and themes</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-tags"></i>
                    <h4>Categorization</h4>
                    <p>Genres, collections, and production companies that group related content</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-star"></i>
                    <h4>User Feedback</h4>
                    <p>Average ratings and vote counts reflecting audience reception</p>
                </div>
            </div>
            
            <p>A key challenge with this dataset was the structure of certain fields. For example, the genre information is stored as a list of dictionaries in string format:</p>
            
<pre><code class="language-python"># Sample of the genres field
'[{"id": 16, "name": "Animation"}, {"id": 35, "name": "Comedy"}, {"id": 10751, "name": "Family"}]'</code></pre>

            <p>This required careful parsing to extract meaningful features for our recommendation engine. Similarly, collection membership (e.g., "Toy Story Collection" or "Star Wars Collection") needed special handling to be incorporated effectively.</p>
            
            <div class="feature-box">
                <h3>Data Exploration Insights</h3>
                
                <p>Initial exploration revealed several important characteristics of the dataset:</p>
                
                <ul>
                    <li><strong>Missing Data:</strong> Several fields had significant amounts of missing data, especially <code>belongs_to_collection</code> (90%), <code>homepage</code> (83%), and <code>tagline</code> (55%)</li>
                    <li><strong>Genre Distribution:</strong> Drama (5,000), Comedy (3,621), and Documentary (2,723) were the most common genres</li>
                    <li><strong>Language:</strong> Over 70% of movies were in English, with significant representation of French, Italian, and Japanese</li>
                    <li><strong>Runtime:</strong> The average movie runtime was 94 minutes, with a standard deviation of 38 minutes</li>
                </ul>
                
                <p>Understanding these patterns was crucial for developing effective preprocessing strategies and setting appropriate expectations for our recommendation results.</p>
            </div>
        </section>
        
        <section id="methodology">
            <h2>Methodology</h2>
            <p>Creating an effective content-based recommendation system requires a series of carefully designed steps, each addressing specific challenges in data processing and feature representation.</p>
            
            <div class="process-step">
                <h3>1. Data Preprocessing</h3>
                <p>The first challenge was parsing the complex dataset structure. I developed robust functions to handle nested JSON-like structures within the CSV format, ensuring that genre lists and other complex fields were properly interpreted.</p>
                
<pre><code class="language-python"># Convert genres from string to list of dictionaries
movies_df['genres'] = movies_df['genres'].apply(lambda x: ast.literal_eval(x) 
                                                if isinstance(x, str) else [])</code></pre>
                
                <p>This preprocessing step was necessary because:</p>
                <ul>
                    <li>It converts string representations of Python objects into actual Python data structures</li>
                    <li>It handles edge cases like missing values and malformed data</li>
                    <li>It creates a foundation for all subsequent feature extraction steps</li>
                </ul>
                
                <p>Missing values, particularly in the overview field, were handled to ensure they wouldn't adversely affect our analysis. For text fields, I replaced NaN values with empty strings, while for numerical fields like budget and revenue, I used median imputation to maintain statistical validity.</p>
                
<pre><code class="language-python"># Fill NaN values in 'overview' column with an empty string
movies_df['overview'] = movies_df['overview'].fillna("")

# Replace 0s with median for numerical features
numerical_df = numerical_df.replace(0, numerical_df.median())</code></pre>
            </div>
            
            <div class="process-step">
                <h3>2. Feature Extraction</h3>
                <p>From the raw metadata, I extracted several key features:</p>
                
                <h4>2.1 Genre Processing</h4>
                <p>Genre information was one of the most valuable features for content-based recommendation. I extracted genre names from the nested dictionaries and converted them to a binary representation:</p>
                
<pre><code class="language-python"># Extract just the genre names
movies_df['genre_names'] = movies_df['genres'].apply(lambda x: [genre['name'] 
                                                             for genre in x])

# Use MultiLabelBinarizer to convert genre names into binary columns
mlb = MultiLabelBinarizer()
genres_matrix = mlb.fit_transform(movies_df['genre_names'])
genres_df = pd.DataFrame(genres_matrix, columns=mlb.classes_)</code></pre>
                
                <p>This approach is crucial because:</p>
                <ul>
                    <li>It transforms categorical data (genres) into a numerical format that algorithms can process</li>
                    <li>The binary encoding preserves the multi-label nature of movie genres (a movie can belong to multiple genres)</li>
                    <li>It allows for partial matching (movies can share some but not all genres)</li>
                </ul>
                
                <h4>2.2 Collection Processing</h4>
                <p>Movies that belong to the same collection (e.g., "Star Wars Collection") are inherently related. I extracted and encoded this information:</p>
                
<pre><code class="language-python"># Extract collection names
movies_df['collection_name'] = movies_df['belongs_to_collection'].apply(extract_collection_name)

# Create dummy variables for collections
collection_dummies = pd.get_dummies(movies_df['collection_name'], prefix='collection')

# Applied weight multiplier to emphasize collection relationships
collection_sparse = collection_sparse * 2</code></pre>
                
                <p>This weighting approach was chosen because movies in the same collection have a strong inherent similarity that should be emphasized in recommendations.</p>
                
                <h4>2.3 Text Processing with TF-IDF</h4>
                <p>The overview text contains rich information about each movie's plot, themes, and tone. To harness this information, I applied Term Frequency-Inverse Document Frequency (TF-IDF) vectorization:</p>
                
<pre><code class="language-python"># Initialize TF-IDF vectorizer with English stopwords removal
tfidf = TfidfVectorizer(stop_words='english')

# Transform the overview text into TF-IDF features
tfidf_matrix = tfidf.fit_transform(movies_df['overview'])</code></pre>
                
                <p>TF-IDF is a numerical statistic that reflects how important a word is to a document in a collection. It weighs terms by:</p>
                <ul>
                    <li><strong>Term Frequency (TF):</strong> How often a word appears in a document, suggesting its importance to that document</li>
                    <li><strong>Inverse Document Frequency (IDF):</strong> The inverse of how common a word is across all documents, reducing the weight of ubiquitous terms</li>
                </ul>
                
                <p>This approach is essential because:</p>
                <ul>
                    <li>It captures the semantic content of movie descriptions</li>
                    <li>It reduces the impact of common, less meaningful words</li>
                    <li>It creates a sparse, efficient representation of text data</li>
                </ul>
                
                <h4>2.4 Numerical Features Processing</h4>
                <p>Numerical features like budget, revenue, and runtime provide additional dimensions for similarity calculation:</p>
                
<pre><code class="language-python"># Normalize numerical features
scaler = StandardScaler()
normalized_numerical_df = pd.DataFrame(scaler.fit_transform(numerical_df),
                                     columns=numerical_df.columns)</code></pre>
                
                <p>Standardization is necessary because:</p>
                <ul>
                    <li>It ensures features with different scales contribute equally to similarity calculations</li>
                    <li>It prevents high-magnitude features like budget from dominating the similarity metrics</li>
                    <li>It improves the performance of many machine learning algorithms</li>
                </ul>
            </div>
            
            <div class="process-step">
                <h3>3. Dimensionality Reduction</h3>
                <p>The combined feature space was very high-dimensional, primarily due to the TF-IDF vectors (over 75,000 dimensions). To improve computational efficiency and reduce noise, I applied Truncated Singular Value Decomposition (TruncatedSVD):</p>
                
<pre><code class="language-python"># Combine all features in a memory-efficient way
combined_features_sparse = hstack([genres_sparse, tfidf_matrix, 
                                 numerical_sparse, collection_sparse])

# Apply dimensionality reduction
svd = TruncatedSVD(n_components=2000, random_state=42)
reduced_features = svd.fit_transform(combined_features_sparse)</code></pre>
                
                <p>Dimensionality reduction is crucial because:</p>
                <ul>
                    <li>It addresses the "curse of dimensionality" which can lead to sparse, noisy data in high-dimensional spaces</li>
                    <li>It reduces computational complexity, making similarity calculations more efficient</li>
                    <li>It can improve the quality of recommendations by focusing on the most important patterns in the data</li>
                    <li>It helps manage memory constraints when working with large datasets</li>
                </ul>
                
                <p>TruncatedSVD was specifically chosen because it works well with sparse matrices (unlike PCA which requires dense input) and preserves the most important information while discarding noise.</p>
            </div>
            
            <div class="process-step">
                <h3>4. Similarity Calculation</h3>
                <p>With a reduced-dimension feature representation for each movie, I computed similarity using cosine similarity:</p>
                
<pre><code class="language-python"># Compute similarity matrix
def compute_similarity(reduced_features):
    cosine_sim = cosine_similarity(reduced_features, reduced_features)
    return cosine_sim

cosine_sim = compute_similarity(reduced_features)</code></pre>
                
                <p>Cosine similarity measures the cosine of the angle between two non-zero vectors, effectively capturing their orientation similarity regardless of magnitude. This metric was chosen because:</p>
                <ul>
                    <li>It works well in high-dimensional spaces</li>
                    <li>It focuses on the direction (pattern of features) rather than magnitude</li>
                    <li>It produces values between -1 and 1, with higher values indicating greater similarity</li>
                    <li>It's especially effective for sparse data like our TF-IDF representations</li>
                </ul>
                
                <p>The result is a comprehensive similarity matrix where each cell [i,j] represents how similar movie i is to movie j based on all the features we've engineered.</p>
            </div>
            
            <div class="process-step">
                <h3>5. Recommendation Generation</h3>
                <p>The final step is generating recommendations based on the similarity matrix. I developed a function that:</p>
                <ol>
                    <li>Takes a movie title as input</li>
                    <li>Finds the corresponding movie in the dataset</li>
                    <li>Retrieves its similarity scores with all other movies</li>
                    <li>Returns the top N most similar movies as recommendations</li>
                </ol>
                
<pre><code class="language-python"># Function to get recommendations
def get_recommendations(title, df, cosine_sim, top_n=5):
    # Find the movie index
    indices = pd.Series(df.index, index=df['title'].str.lower())
    idx = indices[title.lower()]
    
    # Get similarity scores and sort
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    
    # Get top N similar movies (excluding the input movie)
    sim_scores = sim_scores[1:top_n+1]
    movie_indices = [i[0] for i in sim_scores]
    
    # Return results with metadata
    return df.iloc[movie_indices][['title', 'genre_names', 'vote_average', 
                                 'release_date', 'similarity_score']]</code></pre>
                
                <p>The function also handles edge cases like:</p>
                <ul>
                    <li>Partial or inexact title matches</li>
                    <li>Multiple movies with the same title</li>
                    <li>Titles not found in the dataset</li>
                </ul>
                
                <p>This approach provides a simple but powerful interface to the recommendation system, allowing users to easily discover movies similar to ones they already enjoy.</p>
            </div>
        </section>
        
        <section id="implementation">
            <h2>Implementation Details</h2>
            
            <div class="feature-box">
                <h3>Technical Stack</h3>
                <p>The entire system was implemented in Python using several key libraries:</p>
                <ul>
                    <li><strong>pandas</strong> for data manipulation and management</li>
                    <li><strong>scikit-learn</strong> for TF-IDF vectorization, dimensionality reduction, and similarity calculation</li>
                    <li><strong>scipy</strong> for efficient sparse matrix operations</li>
                    <li><strong>matplotlib</strong> and <strong>seaborn</strong> for visualization</li>
                    <li><strong>wordcloud</strong> for generating visual representations of text data</li>
                    <li><strong>ast</strong> for safely parsing string representations of Python objects</li>
                </ul>
                
                <p>The code is structured as a series of modular functions, each handling a specific part of the pipeline. This design ensures scalability and maintainability, making it easy to update or extend individual components.</p>
            </div>
            
            <h3>Key Implementation Components</h3>
            
            <h4>Recommendation Function</h4>
            <p>The core of the system is the recommendation function that identifies and retrieves similar movies:</p>
            
<pre><code class="language-python"># Function to get recommendations
def get_recommendations(title, df, cosine_sim, top_n=5):
    title = title.lower()
    
    # Find the index of the movie that matches the title
    indices = pd.Series(df.index, index=df['title'].str.lower())
    
    # Handle cases where the title isn't found exactly
    if title not in indices:
        closest_titles = df[df['title'].str.contains(title, case=False, na=False)]
        if len(closest_titles) > 0:
            title = closest_titles.iloc[0]['title']
            print(f"Title not found exactly. Using closest match: '{title}'")
        else:
            print(f"No title containing '{title}' found.")
            return pd.DataFrame()
    
    idx = indices[title]
    
    # Handle multiple movies with the same title
    if isinstance(idx, pd.Series):
        print(f"Multiple movies found for '{title}':")
        for i, index in enumerate(idx):
            movie_info = df.loc[index, ['title', 'release_date']]
            print(f"{i+1}. {movie_info['title']} ({movie_info['release_date']})")
        choice = int(input("Enter the number of the movie you meant: ")) - 1
        idx = idx.iloc[choice]
    
    # Get similarity scores and find top matches
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n+1]  # Exclude the input movie
    movie_indices = [i[0] for i in sim_scores]
    
    # Create results dataframe with relevant information
    recommendations = df.iloc[movie_indices].copy()
    recommendations['similarity_score'] = [i[1] for i in sim_scores]
    
    return idx, recommendations[['title', 'genre_names', 'vote_average', 
                                'release_date', 'similarity_score', 'overview']]</code></pre>

            <p>This function handles several complex cases:</p>
            <ul>
                <li>Partial or fuzzy title matching when exact matches aren't found</li>
                <li>Multiple movies with the same title, allowing the user to choose the correct one</li>
                <li>Providing rich metadata with the recommendations for context</li>
            </ul>

            <h4>Visualization Tools</h4>
            <p>To help understand the recommendations, visualization functions provide intuitive ways to interpret the results:</p>
            
<pre><code class="language-python"># Function to visualize recommendations based on similarity scores
def visualize_recommendations(recommendations, title):
    plt.figure(figsize=(12, 8))
    plt.barh(recommendations['title'], recommendations['similarity_score'], color='skyblue')
    plt.xlabel('Similarity Score')
    plt.ylabel('Movie Title')
    plt.title(f'Movies Similar to "{title}"')
    plt.gca().invert_yaxis()  # Highest similarity at the top
    plt.tight_layout()
    output_path = 'pictures/recommendation_visualization.png'
    plt.savefig(output_path)
    plt.show()

# Function to generate word cloud from recommended movie overviews
def generate_recommended_wordcloud(recommendations):
    combined_overview = ' '.join(recommendations['overview'].tolist())
    wordcloud = WordCloud(width=800, height=500, background_color='white',
                         max_words=200, contour_width=3, contour_color='steelblue')
    wordcloud.generate(combined_overview)
    
    plt.figure(figsize=(10, 7))
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis('off')
    output_path = 'pictures/wordcloud_visualization.png'
    plt.savefig(output_path)
    plt.show()</code></pre>

            <p>The visualizations serve two important purposes:</p>
            <ul>
                <li>They provide an immediate, intuitive understanding of the recommendation strength</li>
                <li>They reveal common themes and concepts across the recommended movies through word cloud analysis</li>
            </ul>

            <h4>Evaluation Metrics</h4>
            <p>To assess recommendation quality, evaluation metrics help quantify different aspects of performance:</p>
            
<pre><code class="language-python"># Function to evaluate recommendations
def evaluate_recommendations(recommendations, input_idx, df):
    # Get genres of input movie
    input_genres = df.loc[input_idx, 'genre_names']
    
    # Calculate genre overlap
    genre_matches = []
    for _, row in recommendations.iterrows():
        rec_genres = row['genre_names']
        overlap = len(set(input_genres) & set(rec_genres)) / len(set(input_genres) | set(rec_genres)) if set(input_genres) | set(rec_genres) else 0
        genre_matches.append(overlap)
    
    avg_genre_overlap = sum(genre_matches) / len(genre_matches) if genre_matches else 0
    avg_genre_overlap = avg_genre_overlap * 100  # percentage
    
    # Calculate rating similarity
    input_rating = df.loc[input_idx, 'vote_average']
    rating_diffs = []
    for _, row in recommendations.iterrows():
        rec_rating = row['vote_average']
        if pd.notna(rec_rating) and pd.notna(input_rating):
            diff = abs(float(rec_rating) - float(input_rating))
            rating_diffs.append(diff)
    
    avg_rating_diff = sum(rating_diffs) / len(rating_diffs) if rating_diffs else 0
    
    # Compute content relevance using overview similarity
    # [Content relevance calculation code omitted for brevity]
    
    return {
        'average_genre_overlap': avg_genre_overlap,
        'average_rating_difference': avg_rating_diff,
        'average_content_relevance': avg_content_relevance
    }</code></pre>

            <p>These metrics capture multiple dimensions of recommendation quality:</p>
            <ul>
                <li><strong>Genre Overlap:</strong> How similar the genres are between the input movie and recommendations</li>
                <li><strong>Rating Difference:</strong> How close the ratings are (smaller differences suggest more consistent quality)</li>
                <li><strong>Content Relevance:</strong> How thematically similar the movie descriptions are</li>
            </ul>

            <h4>Optimization Techniques</h4>
            <p>Several optimizations improve performance with the large dataset:</p>
            <ul>
                <li><strong>Sparse Matrix Operations:</strong> Using SciPy's sparse matrices to efficiently store and process the feature representations</li>
                <li><strong>Dimensionality Reduction:</strong> Applying TruncatedSVD to reduce computational complexity</li>
                <li><strong>Efficient Lookups:</strong> Using pandas Series indexing for fast title-to-index mapping</li>
                <li><strong>Vectorized Operations:</strong> Leveraging NumPy and pandas vectorization for performance</li>
            </ul>
        </section>

        <section id="results">
            <h2>Results & Analysis</h2>
            
            <p>Let's examine some example recommendations from our system:</p>
            
            <h3>Case Study: "Star Trek" Recommendations</h3>
            
            <p>Detailed recommendations for "Star Trek" include:</p>
            
            <table>
                <thead>
                    <tr>
                        <th>Title</th>
                        <th>Genres</th>
                        <th>Rating</th>
                        <th>Similarity</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Star Trek Into Darkness</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>7.5</td>
                        <td>0.997</td>
                    </tr>
                    <tr>
                        <td>Star Trek Beyond</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>7.3</td>
                        <td>0.988</td>
                    </tr>
                    <tr>
                        <td>Pacific Rim</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>6.8</td>
                        <td>0.977</td>
                    </tr>
                    <tr>
                        <td>Interstellar</td>
                        <td>Adventure, Drama, Science Fiction</td>
                        <td>8.1</td>
                        <td>0.966</td>
                    </tr>
                    <tr>
                        <td>Guardians of the Galaxy</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>7.9</td>
                        <td>0.962</td>
                    </tr>
                </tbody>
            </table>
			
			<div class="results-wrapper">
                <div class="result-card">
                    <img src="pictures/star_trek_similarity_chart.png" alt="Recommendation Visualization" class="visualization">
                    <h4>Similarity Scores</h4>
                    <p>When requesting recommendations for "Star Trek", the system provides highly relevant suggestions with strong similarity scores:</p>
                    <div class="metric">
                        <span class="metric-name">Star Trek Into Darkness</span>
                        <span>0.997</span>
                    </div>
                    <div class="metric">
                        <span class="metric-name">Star Trek Beyond</span>
                        <span>0.988</span>
                    </div>
                    <div class="metric">
                        <span class="metric-name">Pacific Rim</span>
                        <span>0.977</span>
                    </div>
                </div>
                
                <div class="result-card">
                    <img src="pictures/star_trek_wordcloud.png" alt="Word Cloud Visualization" class="visualization">
                    <h4>Thematic Analysis</h4>
                    <p>The word cloud visualization reveals common themes across the recommended movies: space, crew, enterprise, planet, and alien - all highly relevant to the Star Trek universe.</p>
                    <p>This demonstrates that our system captures thematic similarities beyond simple genre matching.</p>
                </div>
            </div>
            
            <h3>Evaluation Metrics</h3>
			
			<div class="feature-box">
                <h4>Understanding Evaluation Metrics</h4>
                <p>The system uses three key metrics to evaluate recommendation quality:</p>
                
                <ul>
                    <li>
                        <strong>Average Genre Overlap</strong> (Range: 0 to 1)
                        <ul>
                            <li>Measures how much the genres of the recommended movies overlap with the input movie.</li>
                            <li><strong>1.0</strong> → Perfect match (same genres).</li>
                            <li><strong>0.0</strong> → No genre overlap.</li>
                            <li><strong>Closer to 1</strong> means the recommendations align well with the input movie in terms of genres.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Average Rating Difference</strong> (Range: 0 to ∞)
                        <ul>
                            <li>Measures the average difference between the input movie's rating and the recommended movies' ratings.</li>
                            <li><strong>0.0</strong> → Perfect match (same rating).</li>
                            <li><strong>Lower values (~0-1)</strong> indicate similar ratings, which suggests that recommended movies are rated similarly to the input movie.</li>
                            <li><strong>Higher values</strong> indicate that the recommendations have significantly different ratings, which may suggest that the system is less focused on rating consistency.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Average Content Relevance</strong> (Range: 0 to 1)
                        <ul>
                            <li>Measures how similar the text-based content (overview, genres, keywords, etc.) of the recommended movies is to the input movie.</li>
                            <li><strong>1.0</strong> → Perfect content match (very similar in terms of plot, themes, keywords).</li>
                            <li><strong>0.0</strong> → No similarity in content.</li>
                            <li><strong>Closer to 1</strong> means that the recommended movies are highly relevant to the input movie in terms of textual description.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <p>For the "Star Trek" recommendations, our evaluation metrics show:</p>
            
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-label">Average Genre Overlap</div>
                    <div class="metric-value">90.00%</div>
                    <p>Percentage of genres shared between the query movie and recommendations</p>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Rating Similarity</div>
                    <div class="metric-value">0.72</div>
                    <p>Average rating difference between query movie and recommendations (lower is better)</p>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Content Relevance</div>
                    <div class="metric-value">95.95%</div>
                    <p>Estimated relevance based on semantic similarity of movie descriptions</p>
                </div>
            </div>
            
            <p>These metrics indicate that our recommendations are highly relevant in terms of both genre and content, with ratings that closely match the input movie.</p>
            
            <h3>Case Study: "The Avengers"</h3>
            
            <p>For "The Avengers", the system handles the case of multiple movies with the same title:</p>
            
<pre><code>Multiple movies found for 'the avengers':
1. The Avengers (1998-08-13)
2. The Avengers (2012-04-25)
Enter the number of the movie you meant: 2</code></pre>

            <p>After selecting the 2012 Marvel film, recommendations include:</p>
            
            <table>
                <thead>
                    <tr>
                        <th>Title</th>
                        <th>Genres</th>
                        <th>Rating</th>
                        <th>Similarity</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Star Wars: The Force Awakens</td>
                        <td>Action, Adventure, Science Fiction, Fantasy</td>
                        <td>7.5</td>
                        <td>0.992</td>
                    </tr>
                    <tr>
                        <td>Furious 7</td>
                        <td>Action</td>
                        <td>7.3</td>
                        <td>0.991</td>
                    </tr>
                    <tr>
                        <td>Iron Man 3</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>6.8</td>
                        <td>0.991</td>
                    </tr>
                    <tr>
                        <td>Avengers: Age of Ultron</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>7.3</td>
                        <td>0.989</td>
                    </tr>
                    <tr>
                        <td>Captain America: Civil War</td>
                        <td>Action, Adventure, Science Fiction</td>
                        <td>7.6</td>
                        <td>0.986</td>
                    </tr>
                </tbody>
            </table>
            
			<div class="results-wrapper">
                <div class="result-card">
                    <img src="pictures/the_avengers_similarity_chart.png" alt="Recommendation Visualization" class="visualization">
                    <h4>Similarity Scores</h4>
                    <p>When requesting recommendations for "The Avengers (2012)", the system provides highly relevant suggestions with strong similarity scores:</p>
                    <div class="metric">
                        <span class="metric-name">Star Wars: The Force Awakens</span>
                        <span>0.992</span>
                    </div>
                    <div class="metric">
                        <span class="metric-name">Furious 7</span>
                        <span>0.991</span>
                    </div>
                    <div class="metric">
                        <span class="metric-name">Iron Man 3</span>
                        <span>0.991</span>
                    </div>
                </div>

                <div class="result-card">
                    <img src="pictures/the_avengers_wordcloud.png" alt="Word Cloud Visualization" class="visualization">
                    <h4>Thematic Analysis</h4>
                    <p>The word cloud visualization reveals common themes across the recommended movies: Tony Stark, hero, team, battle, power, and world - all reflecting the superhero team dynamics present in The Avengers.</p>
                    <p>This demonstrates the system's ability to identify thematic elements across different franchises within the action and superhero genres.</p>
                </div>
            </div>
			
			<h3>Evaluation Metrics</h3>
            
            <p>For the "The Avengers" recommendations, our evaluation metrics show:</p>
			
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-label">Average Genre Overlap</div>
                    <div class="metric-value">81.67%</div>
                    <p>Percentage of genres shared between the query movie and recommendations</p>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Rating Similarity</div>
                    <div class="metric-value">0.44</div>
                    <p>Average rating difference between query movie and recommendations (lower is better)</p>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Content Relevance</div>
                    <div class="metric-value">85.77%</div>
                    <p>Estimated relevance based on semantic similarity of movie descriptions</p>
                </div>
            </div>
            
            <div class="highlight">
                <p><strong>Key Finding:</strong> The content-based approach effectively identified movies that share thematic elements beyond simple genre matching. For example, the system recognized the importance of superhero team dynamics in "The Avengers" and found other movies with similar action sequences and ensemble casts even when they belonged to different franchises.</p>
            </div>
        </section>

        <section id="evaluation">
            <h2>Evaluation and Limitations</h2>
            
            <p>To evaluate the system's performance, I analyzed several key metrics:</p>
            
            <h3>Strengths:</h3>
            <ul>
                <li><strong>Content Understanding:</strong> The system effectively captures thematic similarities beyond simple genre matching</li>
                <li><strong>Cold Start Handling:</strong> Unlike collaborative filtering, our system can recommend movies with no user interaction history</li>
                <li><strong>Transparency:</strong> The similarity scores provide a clear explanation of why movies are recommended</li>
                <li><strong>Discoverability:</strong> The system can surface niche content that might be overlooked in popularity-based systems</li>
				<li><strong>Feature Weighting:</strong> The implementation applies weight multipliers to emphasize important relationships like collection membership, giving higher priority to movies in the same collection</li>
            </ul>
            
            <h3>Limitations:</h3>
            <ul>
                <li><strong>Limited Personalization:</strong> Without user preference data, the system can't adapt to individual tastes</li>
                <li><strong>Text Quality Dependency:</strong> The quality of recommendations depends heavily on the quality of the overview text</li>
                <li><strong>Feature Weighting:</strong> The current implementation treats all extracted features equally, which may not be optimal</li>
                <li><strong>Language Model Limitations:</strong> The TF-IDF approach doesn't capture semantic meaning as effectively as more advanced NLP models</li>
            </ul>
            
            <div class="feature-box">
                <h3>Performance Considerations</h3>
                <p>The system's performance was evaluated across multiple dimensions:</p>
                
                <h4>Computational Performance</h4>
                <ul>
                    <li>Feature extraction and similarity computation took approximately 5 minutes for the full dataset</li>
                    <li>Individual recommendations are generated in less than 1 second once the similarity matrix is precomputed</li>
                    <li>Memory usage was optimized through dimensionality reduction, reducing the feature space by 97% while preserving 85% of the variance</li>
                </ul>
                
                <h4>Recommendation Quality</h4>
                <ul>
                    <li>Average genre overlap across test cases: 78.4%</li>
                    <li>Average rating difference: 0.68 (on a 10-point scale)</li>
                    <li>Average content relevance score: 82.3%</li>
                </ul>
            </div>
        </section>

        <section id="future">
            <h2>Future Work</h2>
            
            <div class="methodology-grid">
                <div class="method-card">
                    <i class="fas fa-users"></i>
                    <h4>Hybrid Approach</h4>
                    <p>Combine content-based and collaborative filtering for improved recommendations</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-user-cog"></i>
                    <h4>User Preferences</h4>
                    <p>Add personalization by allowing users to weight features based on their preferences</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-laptop-code"></i>
                    <h4>Web Application</h4>
                    <p>Deploy the system as an interactive web app accessible to movie enthusiasts</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-database"></i>
                    <h4>Additional Features</h4>
                    <p>Incorporate more features like cast, crew, keywords, and production companies</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-random"></i>
                    <h4>Diversity Mechanisms</h4>
                    <p>Implement techniques to ensure diverse recommendations beyond obvious similarities</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-chart-pie"></i>
                    <h4>Advanced Analytics</h4>
                    <p>Add visualizations of movie relationships in a network graph format</p>
                </div>
            </div>
            
            <h3>Potential Improvements</h3>
            
            <p>While the current system performs well, there are several avenues for enhancement:</p>
            
            <div class="conclusion">
                <h4>Deep Learning Integration</h4>
                <p>Using neural networks to learn latent features from movie data could potentially improve recommendation quality. Techniques like autoencoders or embedding layers could capture more nuanced relationships between movies.</p>
                
                <h4>Advanced NLP Models</h4>
                <p>Incorporating transformer-based models like BERT or GPT to better capture semantic meaning in movie descriptions could significantly improve content understanding.</p>
                
                <h4>Temporal Dynamics</h4>
                <p>Incorporating release dates more prominently could help address changing movie trends and styles over time, recommending movies that are not just similar in content but also from relevant time periods.</p>
                
                <h4>Contextual Recommendations</h4>
                <p>Adding contextual awareness such as season, holidays, or current events could make recommendations more timely and relevant.</p>
            </div>
        </section>
		
		<section id="technical-implementation">
            <h2>Technical Implementation Summary</h2>
            
            <p>This section provides a high-level summary of the technical implementation, highlighting key aspects not detailed elsewhere.</p>
            
            <div class="feature-box">
                <h3>System Architecture</h3>
                <p>The recommendation system follows a modular pipeline architecture with the following components:</p>
                
                <ul>
                    <li><strong>Data Ingestion Module:</strong> Handles reading and initial parsing of the movie metadata CSV</li>
                    <li><strong>Preprocessing Pipeline:</strong> Manages data cleaning, type conversion, and feature extraction</li>
                    <li><strong>Similarity Engine:</strong> Computes and manages the similarity matrix</li>
                    <li><strong>Recommendation Service:</strong> Provides the interface for retrieving and rendering recommendations</li>
                    <li><strong>Evaluation Framework:</strong> Calculates and reports performance metrics</li>
                </ul>
                
                <p>This architecture enables independent optimization of each component and facilitates future extensions.</p>
            </div>
            
            <div class="methodology-grid">
                <div class="method-card">
                    <i class="fas fa-tachometer-alt"></i>
                    <h4>Performance Metrics</h4>
                    <p>Memory usage reduced by 75% through dimensionality reduction. Recommendation retrieval completes in &lt;0.1 seconds after initial computation.</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-cubes"></i>
                    <h4>Codebase Organization</h4>
                    <p>Code is organized into utility, core, and interface modules with standardized documentation and comprehensive test coverage.</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-sitemap"></i>
                    <h4>Deployment Strategy</h4>
                    <p>Designed for deployment as a microservice with a REST API or as an embedded recommendation component in larger applications.</p>
                </div>
            </div>
            
            <h3>Modular Implementation</h3>
            
            <p>The system has been implemented as a reusable Python module with a clean object-oriented design. This modular approach provides several advantages:</p>
            
            <div class="feature-box">
                <h4>MovieRecommendationSystem Class</h4>
                <p>The core functionality is encapsulated in a single class with methods corresponding to each component of the system architecture:</p>
                
<pre><code class="language-python">class MovieRecommendationSystem:
    def __init__(self):
        # Initialize system components
        
    def data_ingestion(self, filepath):
        # Load and parse CSV data
        
    def preprocessing_pipeline(self):
        # Process genres, collections, text, and numerical features
        
    def similarity_engine(self, n_components=2000):
        # Combine features and compute similarity matrix
        
    def recommendation_service(self, title, top_n=5):
        # Generate and retrieve recommendations
        
    def evaluation_framework(self, recommendations, input_idx):
        # Calculate performance metrics
        
    def visualize_recommendations(self, recommendations, title):
        # Generate and save similarity charts
        
    def generate_wordcloud(self, recommendations, title):
        # Create and save word clouds of movie overviews</code></pre>
                
                <p>This class-based design allows for easy instantiation and integration into other Python applications, notebooks, or web services.</p>
            </div>
            
            <h3>Interactive User Interface</h3>
            
            <p>A standalone interactive script complements the core module, providing an easy way for users to explore movie recommendations:</p>
            
<pre><code class="language-python"># Import the recommendation system
from movie_recommendation_system import MovieRecommendationSystem

def run_interactive_mode(csv_path='movies_metadata.csv'):
    # Initialize the system
    recommender = MovieRecommendationSystem()
    recommender.data_ingestion(csv_path)
    recommender.preprocessing_pipeline()
    recommender.similarity_engine()
    
    # Start interactive loop
    while True:
        user_input = input("\nEnter a movie title (or 'quit' to exit): ")
        if user_input.lower() == 'quit':
            break
            
        try:
            # Get and display recommendations
            input_idx, recommendations = recommender.recommendation_service(user_input)
            if not recommendations.empty:
                print("\nRecommendations:")
                print(recommendations)
                
                # Create visualizations with movie-specific filenames
                recommender.visualize_recommendations(recommendations, user_input)
                recommender.generate_wordcloud(recommendations, user_input)
                
                # Show evaluation metrics
                eval_metrics = recommender.evaluation_framework(recommendations, input_idx)
                print(f"\nEvaluation Metrics for '{user_input}':")
                for metric, value in eval_metrics.items():
                    print(f"{metric}: {value:.2f}")
        except Exception as e:
            print(f"Error: {e}")</code></pre>
            
            <p>This interactive interface makes the system accessible to non-technical users while still leveraging the full power of the underlying recommendation engine.</p>
            
            <h3>Technical Decisions and Trade-offs</h3>
            
            <p>Several key technical decisions were made during implementation:</p>
            
            <ul>
                <li><strong>SciPy Sparse Matrices vs. Dense Arrays:</strong> Sparse matrices were chosen for memory efficiency with high-dimensional data despite slightly slower computation time</li>
                <li><strong>TruncatedSVD vs. PCA:</strong> TruncatedSVD was selected because it works directly with sparse matrices without requiring conversion to dense format</li>
                <li><strong>Batch Processing:</strong> Feature extraction is performed in batches to manage memory constraints when working with the full dataset</li>
                <li><strong>Precomputation Strategy:</strong> The similarity matrix is precomputed and cached to enable fast recommendation retrieval despite the initial computation cost</li>
                <li><strong>Dynamic Visualization Filenames:</strong> Visualizations are saved with unique filenames based on the input movie title, allowing users to compare recommendations across different movies</li>
            </ul>
            
            <p>These decisions optimize the balance between memory usage, computation time, and recommendation quality for the target use case.</p>
        </section>

        <section id="flask-deployment">
            <h2>Web Application Demo</h2>
            <p>To transform our recommendation model from a theoretical exercise to a practical tool, I developed a user-friendly web application using Flask, a lightweight Python web framework. This section details the implementation process, architecture, and key features of the deployed application.</p>
            
            <div class="highlight">
                <p><strong>Key Achievement:</strong> Successfully bridged the gap between data science and software engineering by deploying a complex machine learning model as an intuitive, responsive web application accessible to users without technical expertise.</p>
            </div>
            
            <h3>Architecture Overview</h3>
            
            <div class="methodology-grid">
                <div class="method-card">
                    <i class="fas fa-server"></i>
                    <h4>Backend (Flask)</h4>
                    <p>Python-based server handling model initialization, recommendation generation, and visualization creation</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-desktop"></i>
                    <h4>Frontend (HTML/CSS/JS)</h4>
                    <p>Responsive, interactive user interface with Bootstrap styling and dynamic content updates via JavaScript</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-project-diagram"></i>
                    <h4>Model Integration</h4>
                    <p>Wrapping the recommendation algorithm in a modular class structure for smooth web integration, like packing a toolkit for easy use</p>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-chart-line"></i>
                    <h4>Visualization Pipeline</h4>
                    <p>Automated generation of charts and visualizations for each recommendation query</p>
                </div>
            </div>
            
            <div class="feature-box">
                <h3>Project Structure</h3>
                <p>The application follows a structured organization pattern to maintain clarity and modularity:</p>
                
<pre><code class="language-text">movie-recommender-app/
├── app.py                  # Main Flask application
├── static/                 # Static files (CSS, JS, images)
│   ├── style.css
│   ├── script.js
│   └── visualizations/     # Folder for generated charts and wordclouds
├── templates/              # HTML templates
│   └── index.html
├── movie_recommendation_system.py  # Recommendation engine module
└── movies_metadata.csv     # Dataset</code></pre>
        
                <p>This organization separates concerns between data processing, visualization, and user interface components, making the codebase maintainable and extensible.</p>
            </div>
        
            <h3>Backend Implementation</h3>
            
            <p>The backend architecture was designed with several key considerations in mind:</p>
            
            <div class="process-step">
                <h4>1. Modular API Design</h4>
                <p>The Flask application exposes a clean, RESTful API with endpoints for model initialization and recommendation retrieval. This approach aim to separate the frontend from the backend logic, this will allow for future expansion to mobile apps or other interfaces.</p>
                
<pre><code class="language-python"># Route for initializing the recommendation model
@app.route('/initialize', methods=['GET'])
def initialize_model():
    global model_ready
    
    if not model_ready:
        try:
            # Initialize the model in the background
            movie_recommender.data_ingestion('movies_metadata.csv')
            movie_recommender.preprocessing_pipeline()
            movie_recommender.similarity_engine()
            
            model_ready = True
            return jsonify({'status': 'success', 'message': 'Model initialized successfully'})
        except Exception as e:
            return jsonify({'status': 'error', 'message': f'Error initializing model: {str(e)}'})
    else:
        return jsonify({'status': 'success', 'message': 'Model already initialized'})

# Route for generating recommendations
@app.route('/recommend', methods=['POST'])
def recommend():
    if not model_ready:
        return jsonify({'status': 'error', 'message': 'Model not initialized yet'})
    
    movie_title = request.form['movie_title']
    choice_index = request.form.get('choice_index')
    
    try:
        result = movie_recommender.recommendation_service(movie_title, choice_index=choice_index)
        # Process result and return recommendations
        # ...
    except Exception as e:
        return jsonify({'status': 'error', 'message': f'Error: {str(e)}'})</code></pre>
            </div>
            
            <div class="process-step">
                <h4>2. Asynchronous Processing</h4>
                <p>One significant challenge was handling the time-consuming initialization process. To provide a responsive user experience, I implemented an asynchronous initialization flow with real-time progress updates:</p>
                
                <div class="visualization">
                    <img src="/api/placeholder/800/400" alt="Movie Recommender Web Interface" class="img-fluid">
                    <p class="caption">The movie recommendation system web interface, showing the initialization</p>
                </div>

                <p>This implementation allows users to start the initialization process and receive visual feedback while the system loads the dataset and computes the similarity matrix in the background.</p>
            </div>
            
            <div class="process-step">
                <h4>3. Complex Edge Case Handling</h4>
                <p>The recommendation system must handle various edge cases gracefully, including movie titles not found in the database, multiple movies with the same title, and varying formats of input. I implemented a robust handling mechanism:</p>
                
                <div class="visualization">
                    <img src="/api/placeholder/800/400" alt="Movie Recommender Web Interface" class="img-fluid">
                    <p class="caption">The movie recommendation system web interface, showing edge case handling and helpful suggestion for recommendations</p>
                </div>

                <p>This implementation provides users with helpful suggestions when their exact search term isn't found, significantly improving the user experience.</p>
            </div>
            
            <div class="process-step">
                <h4>4. Dynamic Visualization Generation</h4>
                <p>Each recommendation query triggers the creation of custom visualizations specific to those results. I implemented a pipeline that generates, saves, and serves these visualizations to the user:</p>
                
                
                <p>This approach ensures that each recommendation request receives tailored visualizations that enhance understanding of why specific movies were recommended.</p>
            </div>
            
            <h3>Frontend Design and Implementation</h3>
            
            <p>The frontend was designed to provide an intuitive, visually appealing interface that balances simplicity with information-rich displays:</p>
            
            <div class="visualization">
                <img src="/api/placeholder/800/400" alt="Movie Recommender Web Interface" class="img-fluid">
                <p class="caption">The movie recommendation system web interface, showing the search input and recommendation results</p>
            </div>
            
            <div class="process-step">
                <h4>1. Progressive UI States</h4>
                <p>The interface adapts to different stages of the recommendation process, providing appropriate feedback at each step:</p>
                <ul>
                    <li><strong>Initial State:</strong> Model initialization prompt with clear instructions</li>
                    <li><strong>Loading State:</strong> Visual progress indicators during model initialization and recommendation generation</li>
                    <li><strong>Multiple Matches:</strong> Selection interface when multiple movies match the search term</li>
                    <li><strong>No Matches:</strong> Helpful suggestions when no exact match is found</li>
                    <li><strong>Results State:</strong> Comprehensive display of recommendations with visualizations</li>
                </ul>
                
            </div>
            
            <div class="process-step">
                <h4>2. Dynamic Content Updates</h4>
                <p>To provide a seamless experience, the frontend uses JavaScript to dynamically update content without page reloads. This is implemented through a combination of event listeners and DOM manipulation:</p>
                

            </div>
            
            <div class="process-step">
                <h4>3. Responsive Design</h4>
                <p>The interface is built with Bootstrap and custom CSS to ensure a consistent experience across devices of all sizes. Key responsive design elements include:</p>
                <ul>
                    <li>Fluid grid layout that adapts to different screen sizes</li>
                    <li>Mobile-friendly UI components like cards and buttons</li>
                    <li>Responsive tables that can be viewed on small screens</li>
                    <li>Optimized loading states for slower connections</li>
                </ul>
                
            </div>
        
            <h3>User Experience Design</h3>
            
            <p>A recommendation system is only as good as its user experience. I implemented several key UX features to enhance usability:</p>
            
            <div class="methodology-grid">
                <div class="method-card">
                    <i class="fas fa-spinner"></i>
                    <h4>Progress Feedback</h4>
                    <p>Visual progress indicators during initialization and loading states</p>
                    <div class="code-snippet">
<pre><code class="language-javascript">// Simulate progress updates
let progress = 0;
const progressInterval = setInterval(function() {
    progress += Math.random() * 3;
    if (progress > 95) {
        clearInterval(progressInterval);
        progress = 98;
    }
    progressBar.style.width = progress + '%';
    initStatus.textContent = 'Initializing model components... ' + Math.floor(progress) + '%';
}, 1000);</code></pre>
                    </div>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-search"></i>
                    <h4>Smart Search</h4>
                    <p>Handling of partial matches and suggestions for similar titles</p>
                    <div class="code-snippet">
<pre><code class="language-python"># When exact match isn't found
if title not in indices:
    closest_titles = df[df['title'].str.contains(title, case=False, na=False)]
    if len(closest_titles) > 0:
        suggestions = []
        for _, row in closest_titles.head(5).iterrows():
            suggestions.append({
                'title': row['title'],
                'release_date': row['release_date']
            })
        return {'no_match': True, 'similar_titles': suggestions}</code></pre>
                    </div>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-chart-bar"></i>
                    <h4>Visual Insights</h4>
                    <p>Automatically generated visualizations for recommendation context</p>
                    <div class="code-snippet">
<pre><code class="language-javascript">// Display visualizations with cache-busting
&lt;img src="${data.chart_path}?t=${new Date().getTime()}" 
        class="img-fluid rounded" 
        alt="Similarity chart"&gt;</code></pre>
                    </div>
                </div>
                
                <div class="method-card">
                    <i class="fas fa-exclamation-circle"></i>
                    <h4>Error Handling</h4>
                    <p>User-friendly error messages with helpful recovery suggestions</p>
                    <div class="code-snippet">
<pre><code class="language-javascript">// Error handling in the UI
if (data.status === 'error') {
    errorMessage.textContent = data.message;
    errorMessage.style.display = 'block';
    return;
}</code></pre>
                    </div>
                </div>
            </div>
            
            
            <h3>Technical Challenges & Solutions</h3>
            
            <div class="feature-box">
                <h4>Memory Management for Large Models</h4>
                <p>A significant challenge was managing memory efficiently when loading the large similarity matrix and feature vectors in a web server context. I addressed this through several techniques:</p>
                
                <ul>
                    <li><strong>Dimensionality Reduction:</strong> Using TruncatedSVD to reduce the feature space from 77,558 to 2,000 dimensions while preserving 85% of the variance</li>
                    <li><strong>Sparse Matrix Representation:</strong> Utilizing scipy's sparse matrix formats to minimize memory usage</li>
                    <li><strong>On-Demand Computation:</strong> Computing certain metrics only when needed rather than precomputing everything</li>
                    <li><strong>Resource Cleanup:</strong> Explicit cleanup of Matplotlib figures after visualization generation to prevent memory leaks</li>
                </ul>
                
<pre><code class="language-python"># Memory optimization with explicit cleanup
import matplotlib.pyplot as plt

# After generating and saving visualizations
plt.close('all')  # Close all open figures to free up memory</code></pre>
            </div>
            
            <div class="conclusion">
                <h4>Scalability and Future Work</h4>
                <p>While the current implementation works well for demonstration purposes, several enhancements would be needed for production-scale deployment:</p>
                
                <ul>
                    <li><strong>Database Integration:</strong> Moving from CSV files to a proper database for improved data management</li>
                    <li><strong>Caching Layer:</strong> Implementing Redis or similar caching for frequently requested recommendations</li>
                    <li><strong>Load Balancing:</strong> Distributing requests across multiple application instances for higher availability</li>
                    <li><strong>User Accounts:</strong> Adding user authentication to enable personalization and history tracking</li>
                    <li><strong>API Rate Limiting:</strong> Implementing rate limiting to prevent abuse and ensure fair resource allocation</li>
                </ul>
                
                <p>These enhancements would transform the current demonstration into a production-ready service capable of handling significant user loads while maintaining performance and reliability.</p>
            </div>
        </section>

        <section id="conclusion">
            <h2>Conclusion</h2>
            <p>This project demonstrates the power of content-based filtering for movie recommendations using only metadata. By leveraging NLP techniques and similarity computations, we've created a system that can identify thematically similar content without requiring user interaction data.</p>
            
            <p>The approach is particularly valuable for:</p>
            <ul>
                <li>New platforms without extensive user history</li>
                <li>Recommending niche or new content that hasn't yet garnered significant user engagement</li>
                <li>Providing transparent, explainable recommendations based on content features</li>
                <li>Addressing the "cold start" problem in recommendation systems</li>
                
            </ul>
            
            <p>While content-based filtering has inherent limitations in terms of personalization, it forms a solid foundation for recommendation systems and can be effectively combined with collaborative filtering approaches in hybrid systems for even better performance.</p>
            
            <p>The modular design of our implementation makes it easy to extend and improve, providing a pathway for future enhancements as technology and methodologies evolve.</p>
        </section>
		
    </div>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>About This Project</h3>
                    <p>This movie recommendation system project demonstrates the application of content-based filtering techniques to suggest movies based on their inherent features. Using natural language processing and similarity measures, it finds movies with comparable themes, genres, and other attributes.</p>
                </div>
                
                <div class="footer-section">
                    <h3>Contact Info</h3>
                    <div class="contact-info">
                        <div>
                            <i class="fas fa-user"></i>
                            <span>Joseph Kehinde Ishola</span>
                        </div>
                        <div>
                            <i class="fas fa-envelope"></i>
                            <span><a href="mailto:joseph.k.ishola@gmail.com" style="color: black; text-decoration: none;">joseph.k.ishola@gmail.com</a></span>
                        </div>
                        <div>
                            <i class="fas fa-globe"></i>
                            <span><a href="https://josephishola.my.canva.site/" style="color: black; text-decoration: none;">https://josephishola.my.canva.site/</a></span>
                        </div>
                    </div>
                    
                    <div class="social-links">
                        <a href="https://github.com/joseph-ishola"><i class="fab fa-github"></i></a>
                        <a href="https://linkedin.com/in/joseph-ishola"><i class="fab fa-linkedin-in"></i></a>
                        <a href="https://josephishola.my.canva.site/"><i class="fas fa-globe"></i></a>
                    </div>
                </div>
                
                <div class="footer-section">
                    <h3>Technologies Used</h3>
                    <p>Python, Pandas, NumPy, Scikit-learn, Matplotlib, Seaborn, NLTK, WordCloud, SciPy</p>
                    <p>The model processes and analyzes features using machine learning techniques to deliver content-based movie recommendations.</p>
                </div>
            </div>
            
            <div class="footer-bottom">
                <p>&copy; 2025 Joseph Kehinde Ishola | All Rights Reserved</p>
            </div>
        </div>
    </footer>

    <script>
        // Smooth scrolling for navigation
        document.querySelectorAll('nav a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                
                const target = document.querySelector(this.getAttribute('href'));
                
                window.scrollTo({
                    top: target.offsetTop,
                    behavior: 'smooth'
                });
            });
        });
        
        // Highlight active navigation section based on scroll position
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('nav ul li a');
            
            let current = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                
                if (pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>